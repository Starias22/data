[
    {
        "label": "cv2",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cv2",
        "description": "cv2",
        "detail": "cv2",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "img.read",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "img.read",
        "description": "img.read",
        "detail": "img.read",
        "documentation": {}
    },
    {
        "label": "img.write",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "img.write",
        "description": "img.write",
        "detail": "img.write",
        "documentation": {}
    },
    {
        "label": "writable",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "writable",
        "description": "writable",
        "detail": "writable",
        "documentation": {}
    },
    {
        "label": "read",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "read",
        "description": "read",
        "detail": "read",
        "documentation": {}
    },
    {
        "label": "write",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "write",
        "description": "write",
        "detail": "write",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "radians",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "cos",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "sin",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "pi",
        "importPath": "math",
        "description": "math",
        "isExtraImport": true,
        "detail": "math",
        "documentation": {}
    },
    {
        "label": "convert",
        "kind": 2,
        "importPath": "process.img.convert",
        "description": "process.img.convert",
        "peekOfCode": "def convert(inputPath,outputPath):\n    \"\"\"converts an image from a format to another.\n    Args:\n        inputPath (str): the path of the input file\n        outputPath (str): the path of the output file\n    \"\"\"\n    try:\n        #check if the output path can be written to\n        wtb=wrt.iswritable(outputPath)\n        #otherwise",
        "detail": "process.img.convert",
        "documentation": {}
    },
    {
        "label": "img_exts",
        "kind": 5,
        "importPath": "process.img.convert",
        "description": "process.img.convert",
        "peekOfCode": "img_exts = ['bmp', 'jpg', 'jpeg', 'jpe', 'jp2', 'png',\n                    'webp', 'pbm', 'pgm', 'ppm', 'sr', 'ras', 'tiff', 'tif']\ndef convert(inputPath,outputPath):\n    \"\"\"converts an image from a format to another.\n    Args:\n        inputPath (str): the path of the input file\n        outputPath (str): the path of the output file\n    \"\"\"\n    try:\n        #check if the output path can be written to",
        "detail": "process.img.convert",
        "documentation": {}
    },
    {
        "label": "split",
        "kind": 2,
        "importPath": "process.img.cpt_bgr",
        "description": "process.img.cpt_bgr",
        "peekOfCode": "def split(img):\n    b=img[:,:,0]\n    g=img[:,:,1]\n    r=img[:,:,2]\n    size=img.size\n    print('xxx',img.shape[0]*img.shape[1]*img.shape[2])\n    print('size:',size)\n    b=np.sum(b)\n    g=np.sum(g)\n    r=np.sum(r)",
        "detail": "process.img.cpt_bgr",
        "documentation": {}
    },
    {
        "label": "cpt_bgr",
        "kind": 2,
        "importPath": "process.img.cpt_bgr",
        "description": "process.img.cpt_bgr",
        "peekOfCode": "def cpt_bgr(inputPath):\n    #try to read the image\n    img=reading.read(inputPath)\n    #if failure\n    if img is None:\n        return\n    #else\n    #img=cv.imread(inputPath)\n    return split(img)\nif __name__=='__main__':",
        "detail": "process.img.cpt_bgr",
        "documentation": {}
    },
    {
        "label": "getCropedImg",
        "kind": 2,
        "importPath": "process.img.crop",
        "description": "process.img.crop",
        "peekOfCode": "def getCropedImg(img,x1,y1,x2,y2):\n    \"\"\"Crop an image and return the rectangle matchin the region\n    of interest(ROI).\n    Args:\n        img (numpy.ndarray): the ndarray that represents the image to crop\n        x1 (int): the top of the ROI\n        y1 (int): the left of the ROI\n        x2 (int): the bottom of the ROI\n        y2 (int):the riht of the ROI\n    Raises:",
        "detail": "process.img.crop",
        "documentation": {}
    },
    {
        "label": "crop",
        "kind": 2,
        "importPath": "process.img.crop",
        "description": "process.img.crop",
        "peekOfCode": "def crop(inputPath,outputPath,x1,y1,x2,y2):\n    \"\"\"crops an image\n    Args:\n        inputPath (str): the input path of the image to crop\n        outputPath (str): the output path of the cropped image\n        x1 (int): the top of the ROI\n        y1 (int): the left of the ROI\n        x2 (int): the bottom of the ROI\n        y2 (int):the riht of the ROI\n    Returns:",
        "detail": "process.img.crop",
        "documentation": {}
    },
    {
        "label": "gray",
        "kind": 2,
        "importPath": "process.img.grayscale",
        "description": "process.img.grayscale",
        "peekOfCode": "def gray(inputPath,outputPath):\n    \"\"\"converts an image to grayscale\n    Args:\n        inputPath (str): the path of the input image file\n        outputPath (str): the path of the output image file\n    \"\"\"\n    #img reading\n    try:\n        wtb=wrt.iswritable(outputPath)\n        if wtb is None:",
        "detail": "process.img.grayscale",
        "documentation": {}
    },
    {
        "label": "img_exts",
        "kind": 5,
        "importPath": "process.img.grayscale",
        "description": "process.img.grayscale",
        "peekOfCode": "img_exts = ['bmp', 'jpg', 'jpeg', 'jpe', 'jp2', 'png',\n                    'webp', 'sr', 'ras', 'tiff', 'tif', 'pbm', 'pgm','ppm']\ndef gray(inputPath,outputPath):\n    \"\"\"converts an image to grayscale\n    Args:\n        inputPath (str): the path of the input image file\n        outputPath (str): the path of the output image file\n    \"\"\"\n    #img reading\n    try:",
        "detail": "process.img.grayscale",
        "documentation": {}
    },
    {
        "label": "listImages",
        "kind": 2,
        "importPath": "process.img.list",
        "description": "process.img.list",
        "peekOfCode": "def listImages(path=os.getcwd(),group=False):\n    \"\"\"searches and list the image files in the specified\n        directory or in the current one if none is specified\n    Args:\n        path (str, optional): the path where image files will be\n            searched. Defaults to os.getcwd().\n        group (bool, optional): group them by extension or not.\n            Defaults to False.\n    Raises:\n        FileNotFoundError: if the given path is not found",
        "detail": "process.img.list",
        "documentation": {}
    },
    {
        "label": "img_exts",
        "kind": 5,
        "importPath": "process.img.list",
        "description": "process.img.list",
        "peekOfCode": "img_exts = ['bmp', 'jpg', 'jpeg', 'jpe', 'jp2', 'png',\n                    'webp', 'pbm', 'pgm', 'ppm', 'sr', 'ras', 'tiff', 'tif']\ndef listImages(path=os.getcwd(),group=False):\n    \"\"\"searches and list the image files in the specified\n        directory or in the current one if none is specified\n    Args:\n        path (str, optional): the path where image files will be\n            searched. Defaults to os.getcwd().\n        group (bool, optional): group them by extension or not.\n            Defaults to False.",
        "detail": "process.img.list",
        "documentation": {}
    },
    {
        "label": "getProperties",
        "kind": 2,
        "importPath": "process.img.properties",
        "description": "process.img.properties",
        "peekOfCode": "def getProperties(inputPath):\n    \"\"\"gets the properties of an input image file\n    Args:\n        inputPath (str): the path of the input file\n    Returns:\n        dict: a dictionary that contains each property\n            (height, width, the number of channels, size, gray or not)\n            of the image with it value\n    \"\"\"\n    img=reading.read(inputPath)",
        "detail": "process.img.properties",
        "documentation": {}
    },
    {
        "label": "read",
        "kind": 2,
        "importPath": "process.img.read",
        "description": "process.img.read",
        "peekOfCode": "def read(inputPath):\n    \"\"\"reads an input image file\n    Returns:\n    numpy.ndarray: the ndarray that represents the image.\n    \"\"\"\n    #img reading\n    try:\n        if inputPath=='':\n            raise OSError('Output filename is empty')\n        #if the input file doesn't exist",
        "detail": "process.img.read",
        "documentation": {}
    },
    {
        "label": "getRescaledImg",
        "kind": 2,
        "importPath": "process.img.rescale",
        "description": "process.img.rescale",
        "peekOfCode": "def getRescaledImg(img,hscale,wscale):\n    \"\"\"rescale an image\n    Args:\n        img (numpy.ndarray): the ndarray that represents the image\n        hscale (float): the scale to apply to the image height\n        wscale (float): the scale to apply to the image width\n    Raises:\n        TypeError: if the hscale of the wscale is not integer\n            or float, or is negative.\n    Returns:",
        "detail": "process.img.rescale",
        "documentation": {}
    },
    {
        "label": "rescale",
        "kind": 2,
        "importPath": "process.img.rescale",
        "description": "process.img.rescale",
        "peekOfCode": "def rescale(inputPath,outputPath,hscale,wscale):\n    \"\"\"rescale an image\n    Args:\n        img (numpy.ndarray): the ndarray that represents the image\n        outputPath(str):the destination of the rescaled image\n        hscale (float): the scale to apply to the image height\n        wscale (float): the scale to apply to the image width\n    Raises:\n        TypeError: if the hscale or the wscale is not integer or\n            float, or is negative",
        "detail": "process.img.rescale",
        "documentation": {}
    },
    {
        "label": "getResizedImg",
        "kind": 2,
        "importPath": "process.img.resize",
        "description": "process.img.resize",
        "peekOfCode": "def getResizedImg(img,height,width):\n    \"\"\"resize an image\n    Args:\n        img (numpy.ndarray): the ndarray that represents the image\n        height (int): the new height to apply to the image\n        width (int): the new width to apply to the image\n    Raises:\n        TypeError: if the height or the width is not float, or is negative\n    Returns:\n        None:if failure",
        "detail": "process.img.resize",
        "documentation": {}
    },
    {
        "label": "resize",
        "kind": 2,
        "importPath": "process.img.resize",
        "description": "process.img.resize",
        "peekOfCode": "def resize(inputPath,outputPath,height,width):\n    \"\"\"resize an image\n    Args:\n        inputPath (str): the  path of  the image file\n        height (int): the new height to apply to the image\n        width (int): the new width to apply to the image\n    Raises:\n        TypeError: if the height or the width is not float, or is negative\n    Returns:\n        None: if failure",
        "detail": "process.img.resize",
        "documentation": {}
    },
    {
        "label": "getRotatedImg",
        "kind": 2,
        "importPath": "process.img.rotate",
        "description": "process.img.rotate",
        "peekOfCode": "def getRotatedImg(img,center,angle,scale=1):\n    \"\"\"rotates an image\n    Args:\n        img (numpy.ndarray): the ndarray that represents the\n                image to rotate\n        center (tuple or list): the sequence of length 2 that\n                represents the center of the rotation\n        angle (float): the angle of the rotation in degree\n        scale (int, optional): _the scale. Defaults to 1.\n    Returns:",
        "detail": "process.img.rotate",
        "documentation": {}
    },
    {
        "label": "rotate",
        "kind": 2,
        "importPath": "process.img.rotate",
        "description": "process.img.rotate",
        "peekOfCode": "def rotate(inputPath,outputPath,center,angle,scale=1):\n    wt=wrt.iswritable(outputPath)\n    if wt is None:\n        return\n    img=reading.read(inputPath)\n    if img is None:\n        return\n    #get the exetension of the output and input files\n    outext=outputPath.split('.')[-1]\n    inext=inputPath.split('.')[-1]",
        "detail": "process.img.rotate",
        "documentation": {}
    },
    {
        "label": "getImgWithCircle",
        "kind": 2,
        "importPath": "process.img.shape",
        "description": "process.img.shape",
        "peekOfCode": "def getImgWithCircle(img,center,radius=radius,color=color,thickness=thickness):\n    if img is None:\n        return\n    try:\n        cv.circle(img,center,radius,color,thickness)\n        return img\n    except cv.error as e:\n        print(e)\ndef drawCircle(inputPath,outputPath,center,radius=10,color=[0,0,0],thickness=-1):\n    #img reading",
        "detail": "process.img.shape",
        "documentation": {}
    },
    {
        "label": "drawCircle",
        "kind": 2,
        "importPath": "process.img.shape",
        "description": "process.img.shape",
        "peekOfCode": "def drawCircle(inputPath,outputPath,center,radius=10,color=[0,0,0],thickness=-1):\n    #img reading\n    try:\n        wrtable=wrt.iswritable(outputPath)\n        if  wrtable is None:\n            return\n        #try to read the image\n        img=reading.read(inputPath)\n        #if failure\n        if img is None:",
        "detail": "process.img.shape",
        "documentation": {}
    },
    {
        "label": "circleDrawingEvent",
        "kind": 2,
        "importPath": "process.img.shape",
        "description": "process.img.shape",
        "peekOfCode": "def circleDrawingEvent( event, x, y,img, radius=radius, color=color, thickness=thickness,\n                    wname='xxx'):\n    global drawn;\n    drawn=False\n    print(\"**/*/*/*/\",img)\n    print('Click to draw a circle(Exit in 60s)')\n    print('Press Q/q to exit')\n    key=cv.waitKey(60000)\n    cv.imshow(wname, img)\n    if key==ord('q'):",
        "detail": "process.img.shape",
        "documentation": {}
    },
    {
        "label": {
            "name": "",
            "kind": 2,
            "peekOfCode": "def  pointDrawingEvent(event,x,y,img,radius,color=color,thickness=thickness):\n    if event==cv.EVENT_LBUTTONDOWN:\n        img=getImgWithCircle(img,(x,y))\n        if img is None:\n            return\n        sh.show2('Circle drawing',img)\nname='circle'\ndef drawing(inputPath,outputPath,shape='point',params=''):\n    write=wrt.iswritable(outputPath)\n    if write is None:"
        },
        "kind": 2,
        "importPath": "process.img.shape",
        "description": "process.img.shape",
        "peekOfCode": "def  pointDrawingEvent(event,x,y,img,radius,color=color,thickness=thickness):\n    if event==cv.EVENT_LBUTTONDOWN:\n        img=getImgWithCircle(img,(x,y))\n        if img is None:\n            return\n        sh.show2('Circle drawing',img)\nname='circle'\ndef drawing(inputPath,outputPath,shape='point',params=''):\n    write=wrt.iswritable(outputPath)\n    if write is None:",
        "detail": "process.img.shape",
        "documentation": {}
    },
    {
        "label": "drawing",
        "kind": 2,
        "importPath": "process.img.shape",
        "description": "process.img.shape",
        "peekOfCode": "def drawing(inputPath,outputPath,shape='point',params=''):\n    write=wrt.iswritable(outputPath)\n    if write is None:\n        return\n    inext=inputPath.split('.')[-1]\n    outext=outputPath.split('.')[-1]\n    try:\n        assert inext==outext\n        img=reading.read(inputPath)\n        if img is None:",
        "detail": "process.img.shape",
        "documentation": {}
    },
    {
        "label": "show2",
        "kind": 2,
        "importPath": "process.img.show",
        "description": "process.img.show",
        "peekOfCode": "def show2(label,img):\n    \"\"\"shows an image\n    Args:\n        label (str): the name of the window\n        img (numpy.ndarray): the ndarray that represents the image to show\n    \"\"\"\n    if img is None:\n        return\n    cv.waitKey(0)\n    name=label",
        "detail": "process.img.show",
        "documentation": {}
    },
    {
        "label": "show",
        "kind": 2,
        "importPath": "process.img.show",
        "description": "process.img.show",
        "peekOfCode": "def show(inputPath):\n    \"\"\"shows an image\n    Args:\n        inputPath (str): the path of the input image file to show\n    \"\"\"\n    img=reading.read(inputPath)\n    if img is None:\n        return\n    cv.waitKey(0)\n    name=inputPath.split('/')[-1]",
        "detail": "process.img.show",
        "documentation": {}
    },
    {
        "label": "selectMatch",
        "kind": 2,
        "importPath": "process.img.template",
        "description": "process.img.template",
        "peekOfCode": "def selectMatch(imgsrc,imgTemplate,method=cv.TM_CCOEFF_NORMED,threshold=0.8,color=blue,thickness=2):\n    try:\n        #imgsrc=cv.cvtColor(cv.COLOR_BGR2GRAY)\n        height,width=imgTemplate.shape[:2]\n        tempRes=cv.matchTemplate(imgsrc,imgTemplate,method)\n        loc=np.where(tempRes>=threshold)\n        for (x,y) in zip(*loc[::-1]):\n            cv.rectangle(imgsrc,(x,y),(x+width,y+height),color,thickness)\n        return imgsrc\n    except cv.error as e:",
        "detail": "process.img.template",
        "documentation": {}
    },
    {
        "label": "template",
        "kind": 2,
        "importPath": "process.img.template",
        "description": "process.img.template",
        "peekOfCode": "def template(imgsrcPath,imgTemplatePath,outputPath,\n            method=cv.TM_CCOEFF_NORMED,threshold=0.8,color=blue,thickness=2):\n    try:\n        wrtable=wrt.iswritable(outputPath)\n        if  wrtable is None:\n            return\n        #try to read the img source\n        imgsrc=reading.read(imgsrcPath)\n        imgTemplate=reading.read(imgTemplatePath)\n        #if failure",
        "detail": "process.img.template",
        "documentation": {}
    },
    {
        "label": "iswritable",
        "kind": 2,
        "importPath": "process.img.writable",
        "description": "process.img.writable",
        "peekOfCode": "def iswritable(outputPath):\n    \"\"\"checks if an output path  is writable\n    Args:\n        outputPath (str): the output file path to write to\n    Raises:\n        OSError: if the output file path is empty or a directory\n        FileExistsError: if the output path already exists\n        AssertionError: if the output path doesn't have any extension\n            or if the extension is not supported\n        PermissionError: if the user doesn't have writing access",
        "detail": "process.img.writable",
        "documentation": {}
    },
    {
        "label": "img_exts",
        "kind": 5,
        "importPath": "process.img.writable",
        "description": "process.img.writable",
        "peekOfCode": "img_exts = ['bmp', 'jpg', 'jpeg', 'jpe', 'jp2', 'png',\n                    'webp', 'pbm', 'pgm', 'ppm', 'sr', 'ras', 'tiff', 'tif']\ndef iswritable(outputPath):\n    \"\"\"checks if an output path  is writable\n    Args:\n        outputPath (str): the output file path to write to\n    Raises:\n        OSError: if the output file path is empty or a directory\n        FileExistsError: if the output path already exists\n        AssertionError: if the output path doesn't have any extension",
        "detail": "process.img.writable",
        "documentation": {}
    },
    {
        "label": "imwrite",
        "kind": 2,
        "importPath": "process.img.write",
        "description": "process.img.write",
        "peekOfCode": "def imwrite(img,outputPath):\n    \"\"\"writes an image to the specified output path\n    Args:\n        img (numpy.ndarray): the ndarray that represents the image\n        to write to an output path\n        outputPath (str): the output file path to write image to\n    Returns:\n        bool:True if the writing is successfull\n        None:if failure\n    \"\"\"",
        "detail": "process.img.write",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "training.blob_detection.blob",
        "description": "training.blob_detection.blob",
        "peekOfCode": "img = cv.imread(\"../images/cat2.jpeg\", cv.IMREAD_GRAYSCALE)\n# Set up the detector with default parameters.\ndetector = cv.SimpleBlobDetector()\nprint(\"detection:\",detector)\nprint(\"type(detector):\",type(detector))\n# Detecting blobs.\nkeypoints = detector.detect(img)\n\"\"\"\n# Draw detected blobs as red circles.\n# cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS ensures the size of the circle corresponds to the size of blob",
        "detail": "training.blob_detection.blob",
        "documentation": {}
    },
    {
        "label": "detector",
        "kind": 5,
        "importPath": "training.blob_detection.blob",
        "description": "training.blob_detection.blob",
        "peekOfCode": "detector = cv.SimpleBlobDetector()\nprint(\"detection:\",detector)\nprint(\"type(detector):\",type(detector))\n# Detecting blobs.\nkeypoints = detector.detect(img)\n\"\"\"\n# Draw detected blobs as red circles.\n# cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS ensures the size of the circle corresponds to the size of blob\nim_with_keypoints = cv.drawKeypoints(img, keypoints, np.array([]), (0, 0, 255),\n                                        cv.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS)",
        "detail": "training.blob_detection.blob",
        "documentation": {}
    },
    {
        "label": "keypoints",
        "kind": 5,
        "importPath": "training.blob_detection.blob",
        "description": "training.blob_detection.blob",
        "peekOfCode": "keypoints = detector.detect(img)\n\"\"\"\n# Draw detected blobs as red circles.\n# cv2.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS ensures the size of the circle corresponds to the size of blob\nim_with_keypoints = cv.drawKeypoints(img, keypoints, np.array([]), (0, 0, 255),\n                                        cv.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS)\n# Show keypoints\ncv.imshow(\"Keypoints\", im_with_keypoints)\ncv.waitKey(0)\"\"\"",
        "detail": "training.blob_detection.blob",
        "documentation": {}
    },
    {
        "label": "im_with_keypoints",
        "kind": 5,
        "importPath": "training.blob_detection.blob",
        "description": "training.blob_detection.blob",
        "peekOfCode": "im_with_keypoints = cv.drawKeypoints(img, keypoints, np.array([]), (0, 0, 255),\n                                        cv.DRAW_MATCHES_FLAGS_DRAW_RICH_KEYPOINTS)\n# Show keypoints\ncv.imshow(\"Keypoints\", im_with_keypoints)\ncv.waitKey(0)\"\"\"",
        "detail": "training.blob_detection.blob",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "training.blur.blur",
        "description": "training.blur.blur",
        "peekOfCode": "img = cv.imread(\"../images/cat.jpeg\",cv.IMREAD_COLOR)\ncv.imshow('original image',img)\n#average blur\nblured=cv.blur(img,(3,3))\ncv.imshow('(average) blured image',img)\n#Gaussian blur\ngauss=cv.GaussianBlur(img,(3,3),cv.BORDER_DEFAULT)\ncv.imshow('Gaussian-blured image',gauss)\n#median blur\nblured=cv.medianBlur(img,3)",
        "detail": "training.blur.blur",
        "documentation": {}
    },
    {
        "label": "reverse",
        "kind": 2,
        "importPath": "training.captureVideo.grayscale.gay",
        "description": "training.captureVideo.grayscale.gay",
        "peekOfCode": "def reverse(path):\n    if __main__=='__main__':\n        path='../../videos/video.mp4'\n    capture=cv.VideoCapture(path)\n    if capture.isOpened()",
        "detail": "training.captureVideo.grayscale.gay",
        "documentation": {}
    },
    {
        "label": "getFrames",
        "kind": 2,
        "importPath": "training.captureVideo.reverse_video.reverse",
        "description": "training.captureVideo.reverse_video.reverse",
        "peekOfCode": "def getFrames(path=path):\n    frameList=list()\n    try:\n        capture=cv.VideoCapture(path)\n    except cv.error:\n        print('An error occured while trying to open the video!')\n    #print(capture)\n    #if not capture.isOpened():\n    else :\n        print('Video file opened successfully')",
        "detail": "training.captureVideo.reverse_video.reverse",
        "documentation": {}
    },
    {
        "label": "reverse",
        "kind": 2,
        "importPath": "training.captureVideo.reverse_video.reverse",
        "description": "training.captureVideo.reverse_video.reverse",
        "peekOfCode": "def reverse(path=path,revPath=\"\"):\n    #get the etension of the source video file\n    ext=path.split('.')[-1]\n    revPath='reversed.'+ext\n    print(revPath)\n    frames,fourcc,fps,resol=getFrames(path)\n    print(len(frames),'frames readen')\n    encod=''\n    if ext=='mp4':\n        encod='mp4v'",
        "detail": "training.captureVideo.reverse_video.reverse",
        "documentation": {}
    },
    {
        "label": "cap",
        "kind": 5,
        "importPath": "training.captureVideo.save_video.save",
        "description": "training.captureVideo.save_video.save",
        "peekOfCode": "cap = cv.VideoCapture(0)\n# Define the codec and create VideoWriter object\nfourcc = cv.VideoWriter_fourcc(*'XVID')\nfps=20.0\nresolution=(640,480)\nout_avi = cv.VideoWriter('output.avi',fourcc, fps, resolution)\nwhile(cap.isOpened()):#or while True\n    ret, frame = cap.read()\n    if ret:\n        #frame = cv.flip(frame,0)",
        "detail": "training.captureVideo.save_video.save",
        "documentation": {}
    },
    {
        "label": "fourcc",
        "kind": 5,
        "importPath": "training.captureVideo.save_video.save",
        "description": "training.captureVideo.save_video.save",
        "peekOfCode": "fourcc = cv.VideoWriter_fourcc(*'XVID')\nfps=20.0\nresolution=(640,480)\nout_avi = cv.VideoWriter('output.avi',fourcc, fps, resolution)\nwhile(cap.isOpened()):#or while True\n    ret, frame = cap.read()\n    if ret:\n        #frame = cv.flip(frame,0)\n        # write the flipped frame\n        out_avi.write(frame)",
        "detail": "training.captureVideo.save_video.save",
        "documentation": {}
    },
    {
        "label": "out_avi",
        "kind": 5,
        "importPath": "training.captureVideo.save_video.save",
        "description": "training.captureVideo.save_video.save",
        "peekOfCode": "out_avi = cv.VideoWriter('output.avi',fourcc, fps, resolution)\nwhile(cap.isOpened()):#or while True\n    ret, frame = cap.read()\n    if ret:\n        #frame = cv.flip(frame,0)\n        # write the flipped frame\n        out_avi.write(frame)\n        cv.imshow('frame',frame)\n        if cv.waitKey(1) == ord('q'):\n            break",
        "detail": "training.captureVideo.save_video.save",
        "documentation": {}
    },
    {
        "label": "getFrames",
        "kind": 2,
        "importPath": "training.captureVideo.frame_set",
        "description": "training.captureVideo.frame_set",
        "peekOfCode": "def getFrames(path=path):\n    capture=cv.VideoCapture(path)\n    frameList=list()\n    #print(capture)\n    if not capture.isOpened():\n        print('An error occured while trying to open the video!')\n        return []\n    else :\n        print('Video file opened successfully')\n        #print(capture.get(cv.CAP_PROP_FRAME_COUNT))",
        "detail": "training.captureVideo.frame_set",
        "documentation": {}
    },
    {
        "label": "properties",
        "kind": 2,
        "importPath": "training.captureVideo.properties",
        "description": "training.captureVideo.properties",
        "peekOfCode": "def properties(path=path):\n    #open the video\n    capture=cv.VideoCapture(path)\n    if not capture.isOpened():\n        print('An error occured while trying to open the video.')\n    else :\n        print(\"Video opened successfuly!\");\n        print(\"***Video properties***\")\n        #get the resolution of the video\n        #width",
        "detail": "training.captureVideo.properties",
        "documentation": {}
    },
    {
        "label": "duration",
        "kind": 2,
        "importPath": "training.captureVideo.properties",
        "description": "training.captureVideo.properties",
        "peekOfCode": "def duration(path=path):\n    prs=properties()\n    print(prs)\n    duration=prs[\"fmscount\"]/prs[\"fps\"]\n    return int(duration)\n#print(locals()['cv'])\ntm=duration()\nprint(\"The video lasts\",tm,'seconds')",
        "detail": "training.captureVideo.properties",
        "documentation": {}
    },
    {
        "label": "fps",
        "kind": 5,
        "importPath": "training.captureVideo.read_video",
        "description": "training.captureVideo.read_video",
        "peekOfCode": "fps = capture.get(cv.CAP_PROP_FPS)\nprint(fps,\"frames per second in that video\")\ncount=0\n\"\"\"display the frame while the user press a\nkey different from q\nif he presses q exit and\noutput the number of frames captured\"\"\"\nwhile True:\n    ret,frame=capture.read()\n    print()",
        "detail": "training.captureVideo.read_video",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "training.draw.next",
        "description": "training.draw.next",
        "peekOfCode": "img = cv.imread(\"../images/cat.jpeg\",cv.IMREAD_COLOR)\n#defining points for polylines\npts = np.array([[96,72],[200,115],[115,20],[10,10]], np.int32)\n# pts = pts.reshape((-1,1,2))\ncv.polylines(img, [pts], True, (0,255,255), 3)\ncv.imshow('image',img)\nfont = cv.FONT_HERSHEY_SIMPLEX\ncv.putText(img,'Hack Projects',(10,500), font, 1,(255,255,255),2)\n#Display the image\ncv.imshow(\"Text added\",img)",
        "detail": "training.draw.next",
        "documentation": {}
    },
    {
        "label": "pts",
        "kind": 5,
        "importPath": "training.draw.next",
        "description": "training.draw.next",
        "peekOfCode": "pts = np.array([[96,72],[200,115],[115,20],[10,10]], np.int32)\n# pts = pts.reshape((-1,1,2))\ncv.polylines(img, [pts], True, (0,255,255), 3)\ncv.imshow('image',img)\nfont = cv.FONT_HERSHEY_SIMPLEX\ncv.putText(img,'Hack Projects',(10,500), font, 1,(255,255,255),2)\n#Display the image\ncv.imshow(\"Text added\",img)\ncv.waitKey(0)",
        "detail": "training.draw.next",
        "documentation": {}
    },
    {
        "label": "font",
        "kind": 5,
        "importPath": "training.draw.next",
        "description": "training.draw.next",
        "peekOfCode": "font = cv.FONT_HERSHEY_SIMPLEX\ncv.putText(img,'Hack Projects',(10,500), font, 1,(255,255,255),2)\n#Display the image\ncv.imshow(\"Text added\",img)\ncv.waitKey(0)",
        "detail": "training.draw.next",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "training.edge_detect.canny",
        "description": "training.edge_detect.canny",
        "peekOfCode": "img = cv.imread(\"../images/cat.jpeg\",cv.IMREAD_COLOR)\ncv.imshow('original image',img)\ncanny=cv.Canny(img,100,200)\ncv.imshow('Edge detection with canny',canny)\ncv.waitKey(0)",
        "detail": "training.edge_detect.canny",
        "documentation": {}
    },
    {
        "label": "read",
        "kind": 2,
        "importPath": "training.error_handling.handle_reading",
        "description": "training.error_handling.handle_reading",
        "peekOfCode": "def read(path='normal_cat_img'):#empty, 'jfk',:dosnt exist\n    try:\n        img=cv.imread(path)\n        if img is None:\n            print('File not found or wrong input file')\n            return\n        else:\n            cv.imshow('Image',img)\n            cv.waitKey(0)\n    except cv.error as e:",
        "detail": "training.error_handling.handle_reading",
        "documentation": {}
    },
    {
        "label": "save",
        "kind": 2,
        "importPath": "training.error_handling.handle_writing",
        "description": "training.error_handling.handle_writing",
        "peekOfCode": "def save(rpath='../images/cat.jpeg',wpath='output.png'):\n    try:\n        img=cv.imread(rpath)\n        if img is None:#image not read\n            print('Unable to read: file not found or wrong input file')\n            return\n        else:\n            cv.imshow('image to write',img)\n            cv.waitKey()\n            cv.imwrite(wpath,img)",
        "detail": "training.error_handling.handle_writing",
        "documentation": {}
    },
    {
        "label": "media_io_start",
        "kind": 5,
        "importPath": "training.error_handling.handle_writing",
        "description": "training.error_handling.handle_writing",
        "peekOfCode": "media_io_start = build_info.find(\"Media I/O\")\nmedia_io_end = build_info.find(\"\\n\\n\", media_io_start)\nmedia_io_info = build_info[media_io_start:media_io_end]\n# Split the \"Media I/O\" information into lines\n# and search for the line that contains \"Image codecs:\"\nmedia_io_lines = media_io_info.split(\"\\n\")\nimage_codecs_line = next((line for line in media_io_lines\n                            if \"Image codecs:\" in line), None)\n# Extract the image file extensions from the \"Image codecs:\" line\nif image_codecs_line is not None:",
        "detail": "training.error_handling.handle_writing",
        "documentation": {}
    },
    {
        "label": "media_io_end",
        "kind": 5,
        "importPath": "training.error_handling.handle_writing",
        "description": "training.error_handling.handle_writing",
        "peekOfCode": "media_io_end = build_info.find(\"\\n\\n\", media_io_start)\nmedia_io_info = build_info[media_io_start:media_io_end]\n# Split the \"Media I/O\" information into lines\n# and search for the line that contains \"Image codecs:\"\nmedia_io_lines = media_io_info.split(\"\\n\")\nimage_codecs_line = next((line for line in media_io_lines\n                            if \"Image codecs:\" in line), None)\n# Extract the image file extensions from the \"Image codecs:\" line\nif image_codecs_line is not None:\n    image_codecs = image_codecs_line.split(\":\")[1].strip().split()",
        "detail": "training.error_handling.handle_writing",
        "documentation": {}
    },
    {
        "label": "media_io_info",
        "kind": 5,
        "importPath": "training.error_handling.handle_writing",
        "description": "training.error_handling.handle_writing",
        "peekOfCode": "media_io_info = build_info[media_io_start:media_io_end]\n# Split the \"Media I/O\" information into lines\n# and search for the line that contains \"Image codecs:\"\nmedia_io_lines = media_io_info.split(\"\\n\")\nimage_codecs_line = next((line for line in media_io_lines\n                            if \"Image codecs:\" in line), None)\n# Extract the image file extensions from the \"Image codecs:\" line\nif image_codecs_line is not None:\n    image_codecs = image_codecs_line.split(\":\")[1].strip().split()\n    print(\"Supported image file extensions:\", image_codecs)",
        "detail": "training.error_handling.handle_writing",
        "documentation": {}
    },
    {
        "label": "media_io_lines",
        "kind": 5,
        "importPath": "training.error_handling.handle_writing",
        "description": "training.error_handling.handle_writing",
        "peekOfCode": "media_io_lines = media_io_info.split(\"\\n\")\nimage_codecs_line = next((line for line in media_io_lines\n                            if \"Image codecs:\" in line), None)\n# Extract the image file extensions from the \"Image codecs:\" line\nif image_codecs_line is not None:\n    image_codecs = image_codecs_line.split(\":\")[1].strip().split()\n    print(\"Supported image file extensions:\", image_codecs)\nelse:\n    print(\"Unable to find image codecs in build information\")\"\"\"\nimg_extensions = ['bmp', 'jpg', 'jpeg', 'jpe', 'jp2', 'png',",
        "detail": "training.error_handling.handle_writing",
        "documentation": {}
    },
    {
        "label": "image_codecs_line",
        "kind": 5,
        "importPath": "training.error_handling.handle_writing",
        "description": "training.error_handling.handle_writing",
        "peekOfCode": "image_codecs_line = next((line for line in media_io_lines\n                            if \"Image codecs:\" in line), None)\n# Extract the image file extensions from the \"Image codecs:\" line\nif image_codecs_line is not None:\n    image_codecs = image_codecs_line.split(\":\")[1].strip().split()\n    print(\"Supported image file extensions:\", image_codecs)\nelse:\n    print(\"Unable to find image codecs in build information\")\"\"\"\nimg_extensions = ['bmp', 'jpg', 'jpeg', 'jpe', 'jp2', 'png',\n                    'webp', 'pbm', 'pgm', 'ppm', 'sr', 'ras', 'tiff', 'tif']",
        "detail": "training.error_handling.handle_writing",
        "documentation": {}
    },
    {
        "label": "img_extensions",
        "kind": 5,
        "importPath": "training.error_handling.handle_writing",
        "description": "training.error_handling.handle_writing",
        "peekOfCode": "img_extensions = ['bmp', 'jpg', 'jpeg', 'jpe', 'jp2', 'png',\n                    'webp', 'pbm', 'pgm', 'ppm', 'sr', 'ras', 'tiff', 'tif']\nprint(\"Supported image file extensions:\", img_extensions)",
        "detail": "training.error_handling.handle_writing",
        "documentation": {}
    },
    {
        "label": "kernel",
        "kind": 5,
        "importPath": "training.filters.filter",
        "description": "training.filters.filter",
        "peekOfCode": "kernel = np.ones((5,5),np.float32)/25#5*5 matrix of 0.4 as value\nprint(\"kernel: \",kernel,sep=\"\\n\")\nfilter2D = cv.filter2D(img,-1,kernel)\ncv.imshow(\"Filter2D\",filter2D)\ncv.waitKey(0)",
        "detail": "training.filters.filter",
        "documentation": {}
    },
    {
        "label": "filter2D",
        "kind": 5,
        "importPath": "training.filters.filter",
        "description": "training.filters.filter",
        "peekOfCode": "filter2D = cv.filter2D(img,-1,kernel)\ncv.imshow(\"Filter2D\",filter2D)\ncv.waitKey(0)",
        "detail": "training.filters.filter",
        "documentation": {}
    },
    {
        "label": "read",
        "kind": 2,
        "importPath": "training.imread.imread",
        "description": "training.imread.imread",
        "peekOfCode": "def read(path,label='image'):\n    try:\n        img=cv.imread(path)\n        cv.imshow(label,img)\n        cv.waitKey(0)\n    except cv.error:\n        print(\"The image cannot be readen\")\nread('../images/apple.jpeg','apple')\nread('error')",
        "detail": "training.imread.imread",
        "documentation": {}
    },
    {
        "label": "simple",
        "kind": 2,
        "importPath": "training.mouse_events.callback",
        "description": "training.mouse_events.callback",
        "peekOfCode": "def simple(event,x,y,flags,param):\n    print(\"An mouse event captured at the point\",(x,y))\n    if(event==cv.EVENT_LBUTTONDBLCLK):\n        print('Double click event')\n        #break\n    \"\"\"if (x,y)==(img.shape[1],img.shape[0]):\n        print(\"Center of the image reached:\")\n        return\"\"\"\n\"\"\"Draw circle  with radius r on click\non a point of coordinates(x,y) on the image\"\"\"",
        "detail": "training.mouse_events.callback",
        "documentation": {}
    },
    {
        "label": "draw_circle",
        "kind": 2,
        "importPath": "training.mouse_events.callback",
        "description": "training.mouse_events.callback",
        "peekOfCode": "def draw_circle(event,x,y,flags,param,rad=100):\n    #on the cat image, draw a circle on double click\n    if(event == cv.EVENT_LBUTTONDBLCLK):\n            cv.circle(img,(x,y),rad,(255,255, 0),-1)\n# set callback on mouse\n\"\"\"this method needs the window name and the callable, that\nshould be a function that handle a mouse event\"\"\"\nname=\"draw circle on dbclick\"\nname=\"Simple tests\"\ncv.namedWindow(name)",
        "detail": "training.mouse_events.callback",
        "documentation": {}
    },
    {
        "label": "#mouse_events",
        "kind": 5,
        "importPath": "training.mouse_events.overview",
        "description": "training.mouse_events.overview",
        "peekOfCode": "#mouse_events = [j for j in dir(cv) if 'EVENT' in j]\nmouse_events=list()\n#browse the directory of opencv: for each element inside,\nfor j in dir(cv):\n    #ifthe object contains the word 'EVENT'\n    if 'EVENT' in j:\n    #add it to the list of mouse event\n        mouse_events.append(j)\nprint(\"Opencv provides\",len(mouse_events),\"mouse events\")\nprint('There are')",
        "detail": "training.mouse_events.overview",
        "documentation": {}
    }
]